# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yIkdWTBnADewGKJXBR_6M7QHWFAh0CjZ
"""

# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save & Run All" 
# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session

# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save & Run All" 
# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session

import numpy as np
import pandas as pd
import scipy.sparse as scs
import scipy.linalg as scl
import scipy.optimize as sco
import matplotlib.pylab as plt

import os
data = pd.read_csv("../input/project-1-sudoku-challenge/small1.csv")

!pip install cvxopt

def check_by_row(board_list):
    '''
    Check which value from 1-9 is missing by row and plug in the missing value if the value can be determined.
    '''
    dic = generate_dictionary()
    for i in range(9):
        for j in range(9):
            num = board_list[i][j]
            if num != 0:
                dic[num] = True
        bool_values = list(dic.values())
        count_value = bool_values.count(True)
        if count_value == 8:
            board_list[i][board_list[i].index(0)] = list(range(1,10))[bool_values.index(False)]
        dic = generate_dictionary()
    return board_list

def check_by_column(board_list:list):
  
    '''
    Check which number is missing from 1-9 by column and plug in the missing value if the value can be determined.
    '''
    dic = generate_dictionary()
    for i in range(9):
        for j in range(9):
            num = board_list[j][i]
            if num != 0:
                dic[num] = True
        bool_values = list(dic.values())
        count_value = bool_values.count(True)
        if count_value == 9:
            board_list[i][board_list[i].index(0)] = list(range(1,10))[bool_values.index(False)]
        dic = generate_dictionary()
    return board_list

def check_by_submatrix(board_list:list):
  '''
  Check which number is missing from 1-9 by sub-3x3 matrix and plug in the missing value if the value can be determined.
  '''
  dic = generate_dictionary()
  for i in range(9):
      for j in range(9):
          num = board_list[i][j]
          if num != 0:
              dic[num] = True
      bool_values = list(dic.values())
      count_value = bool_values.count(True)
      if count_value == 8:
          board_list[i][board_list[i].index(0)] = list(range(1,10))[bool_values.index(False)]
      dic = generate_dictionary()
  return board_list

def generate_dictionary()-> dict:
  '''
  A helper function. 
  '''
  dic = {}
  for i in range(1, 10):
      dic[i] = False
  return dic

def convert_to_recursive_list(board):
    '''
    Convert the board into a recursive list; each list is one row of the board.
    :board_idx: the index of quizzes
    '''
    lst = list(board)
    temp_list = []
    full_list = []
    for index, num in enumerate(lst):
            temp_list.append(int(num))
            index += 1
            if index % 9 == 0:
                full_list.append(temp_list)
                temp_list = []
    return full_list

def plugged_grids(board_list:list):
  '''Plug predetermined grids for the board_list.'''
  board_list = check_by_row(board_list);
  board_list = check_by_column(board_list);  
  board_list = check_by_submatrix(board_list);
  return board_list

def index_to_plugged_grids(board_idx:int):
  '''Get a predetermined grids plugged board_list from the index.'''
  board_list = convert_to_recursive_list(board_idx);
  board_list = plugged_grids(board_list);
  return flattened_list

def fixed_constraints(N=9):
  A_eq = [];
 
# Each number appears onces in each row(i represents row, j represents column, k represents number)
  for j in range(9):
    for k in range(9):
      zeros = np.zeros((729));
      A = zeros.tolist();
      for i in range(9):
        A[(81*i+9*j+k)]=1;
      A_eq = A_eq + [A];
# Each number appears once in each column
  for i in range(9):
    for k in range(9):
      zeros = np.zeros((729));
      A = zeros.tolist();
      for j in range(9):
        A[(81*i+9*j+k)]=1;
      A_eq = A_eq + [A];
# Each number appears once in each subgrid
  for a in range(3):
    for c in range(3):
      for k in range(9):
        zeros = np.zeros((729));
        A = zeros.tolist();
        for b in range(3):
          for d in range(3):
            A[81*(3*a+b)+9*(3*c+d)+k]=1;
        A_eq = A_eq + [A];
# Each grid has one number
  for i in range(9):
    for j in range(9):
      zeros = np.zeros((729));
      A = zeros.tolist();
      for k in range(9):
        A[(81*i+9*j+k)]=1;
      A_eq = A_eq + [A];
  return A_eq

def given_constraint(quiz):
    board_list = convert_to_recursive_list(quiz); # Convert quiz string to 9*9 recursive list
    board_array = np.array(board_list); # Convert list to array
    # Find out the location of nonzero elements in board_array
    row = []; 
    column = [];
    for j in range(9):
      for k in range(9):
        if board_array[j][k] != 0:
          row.append(j)
          column.append(k)
    row = np.array(row);
    column = np.array(column);
    # List these nonzero elements
    nonzero_values = np.array([board_array[row[d],column[d]] for d in range(len(row))])
    
    location_in_string = 9 * row + column;
    nonzero_and_location = np.block([[nonzero_values],[location_in_string]])
    
    # Use lil_matrix to set an empty len(location_in_string)*729 matrix
    given_constraints = scs.lil_matrix((len(location_in_string), 729))
    # put 1 in the right positions
    for i in range(len(location_in_string)):
        given_constraints[i,location_in_string[i]*9 + nonzero_values[i] - 1] = 1;
    # change back to csr_matrix.
    given_constraints = given_constraints.tocsr() 
    
    return given_constraints

from cvxopt import solvers, matrix
import time
import random
solvers.options['show_progress'] = False

# Import the data

quizzes = data['quizzes'];
solutions = data['solutions'];

corr_cnt = 0
start = time.time()
index = list(range(len(data)))
random_index = random.choices(index,k=1000)
for i in range(len(data)):
    # Set the problem
    quiz = quizzes[i];
    solution = solutions[i];
    # combine all constraints
    A_fixed = fixed_constraints();
    A_given = given_constraint(quiz);

    A_vstack = scs.vstack((A_fixed,A_given));
    A_vstack = A_vstack.toarray();
    one = np.ones(A_vstack.shape[0]);
    # Give A Full Rank, convert the problem to a full-rank problem
    u, s, vh = np.linalg.svd(A_vstack, full_matrices=False)
    nonzero_in_s = np.sum(s>1e-5)
    S_ = np.block([np.diag(s[:nonzero_in_s]), np.zeros((nonzero_in_s, A_vstack.shape[0]-nonzero_in_s))])
    A_svd = S_@vh
    one = u.T@one;
    one = one[:nonzero_in_s];
    # Set the linear optimization problem
    c = matrix(np.ones(1458))
    G = matrix(np.block([[-np.eye(729),np.zeros((729,729))],[np.zeros((729,729)),-np.eye(729)]]))
    h = matrix(np.block([0*np.ones(729),np.zeros(729)]))
    A = matrix(np.block([A_svd, -A_svd]))
    b = matrix(one);
    # Solve it
    sol = solvers.lp(c,G,h,A,b);
    X = np.array(sol['x']).T[0];
    x = X[:729] - X[729:];
    
    # map to board
    answer_string = ''
    for j in range(81):
      for k in range(1,10):
        if round(x[9*j+k-1]) == 1:
            string_number = f'{k}'
            answer_string = answer_string + string_number;

    if answer_string == solution:
        #print("CORRECT")
        corr_cnt += 1
    
    if (i+1) % 5 == 0:
        end = time.time()
        print("Aver Time: {t:6.2f} secs. Success rate: {corr} / {all} ".format(t=(end-start)/(i+1), corr=corr_cnt, all=i+1 ))
end = time.time()
print("Aver Time: {t:6.2f} secs. Success rate: {corr} / {all} ".format(t=(end-start)/(i+1), corr=corr_cnt, all=i+1) )

from cvxopt import solvers, matrix
import time
import random
solvers.options['show_progress'] = False

# Import the data

quizzes = data['quizzes'];
solutions = data['solutions'];

corr_cnt = 0
start = time.time()
index = list(range(len(data)))
random_index = random.choices(index,k=1000)
for i in range(len(data)):
    # Set the problem
    quiz = quizzes[i];
    solution = solutions[i];
    # combine all constraints
    A_fixed = fixed_constraints();
    A_given = given_constraint(quiz);

    A_vstack = scs.vstack((A_fixed,A_given));
    A_vstack = A_vstack.toarray();
    one = np.ones(A_vstack.shape[0]);
    # Give A Full Rank, convert the problem to a full-rank problem
    u, s, vh = np.linalg.svd(A_vstack, full_matrices=False)
    nonzero_in_s = np.sum(s>1e-5)
    S_ = np.block([np.diag(s[:nonzero_in_s]), np.zeros((nonzero_in_s, A_vstack.shape[0]-nonzero_in_s))])
    A_svd = S_@vh
    one = u.T@one;
    one = one[:nonzero_in_s];
    # Set the linear optimization problem
    c = matrix(np.ones(1458))
    G = matrix(np.block([[-np.eye(729),np.zeros((729,729))],[np.zeros((729,729)),-np.eye(729)]]))
    h = matrix(np.block([0*np.ones(729),np.zeros(729)]))
    A = matrix(np.block([A_svd, -A_svd]))
    b = matrix(one);
    # Solve it
    sol = solvers.lp(c,G,h,A,b);
    X = np.array(sol['x']).T[0];
    x = X[:729] - X[729:];
    
    # map to board
    answer_string = ''
    for j in range(81):
      for k in range(1,10):
        if round(x[9*j+k-1]) == 1:
            string_number = f'{k}'
            answer_string = answer_string + string_number;

    if answer_string == solution:
        #print("CORRECT")
        corr_cnt += 1
    
    if (i+1) % 5 == 0:
        end = time.time()
        print("Aver Time: {t:6.2f} secs. Success rate: {corr} / {all} ".format(t=(end-start)/(i+1), corr=corr_cnt, all=i+1 ))
end = time.time()
print("Aver Time: {t:6.2f} secs. Success rate: {corr} / {all} ".format(t=(end-start)/(i+1), corr=corr_cnt, all=i+1) )