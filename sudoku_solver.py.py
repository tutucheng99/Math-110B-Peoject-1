# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1toeR3YcUcRgqWMgN2sqtyPyVzU3B5Cbl
"""

from google.colab import files
uploaded = files.upload()
data = pd.read_csv("small1.csv")

import os
data = pd.read_csv("../input/small1.csv")

import numpy as np
import pandas as pd
import scipy.sparse as scs
import scipy.linalg as scl
import scipy.optimize as sco
import matplotlib.pylab as plt

!pip install cvxopt

def check_by_submatrix(board_list:list):
  '''
  Check which number is missing from 1-9 by sub-3x3 matrix and plug in the missing value if the value can be determined.
  '''
  dic = generate_dictionary()
  for i in range(9):
      for j in range(9):
          num = board_list[i][j]
          if num != 0:
              dic[num] = True
      bool_values = list(dic.values())
      count_value = bool_values.count(True)
      if count_value == 8:
          board_list[i][board_list[i].index(0)] = list(range(1,10))[bool_values.index(False)]
      dic = generate_dictionary()
  return board_list

def plugged_grids(board_list:list):
  '''Plug predetermined grids for the board_list.'''
  board_list = check_by_row(board_list);
  board_list = check_by_column(board_list);  
  board_list = check_by_submatrix(board_list);
  return board_list

def index_to_plugged_grids(board_idx:int):
  '''Get a predetermined grids plugged board_list from the index.'''
  board_list = convert_to_recursive_list(board_idx);
  board_list = plugged_grids(board_list);
  return flattened_list

def fixed_constraints(N=9):
  A_eq = [];
 
# Each number appears onces in each row(i represents row, j represents column, k represents number)
  for j in range(9):
    for k in range(9):
      zeros = np.zeros((729));
      A = zeros.tolist();
      for i in range(9):
        A[(81*i+9*j+k)]=1;
      A_eq = A_eq + [A];
# Each number appears once in each column
  for i in range(9):
    for k in range(9):
      zeros = np.zeros((729));
      A = zeros.tolist();
      for j in range(9):
        A[(81*i+9*j+k)]=1;
      A_eq = A_eq + [A];
# Each number appears once in each subgrid
  for a in range(3):
    for c in range(3):
      for k in range(9):
        zeros = np.zeros((729));
        A = zeros.tolist();
        for b in range(3):
          for d in range(3):
            A[81*(3*a+b)+9*(3*c+d)+k]=1;
        A_eq = A_eq + [A];
# Each grid has one number
  for i in range(9):
    for j in range(9):
      zeros = np.zeros((729));
      A = zeros.tolist();
      for k in range(9):
        A[(81*i+9*j+k)]=1;
      A_eq = A_eq + [A];
  return A_eq 
 
def given_constraint(quiz):
    board_list = convert_to_recursive_list(quiz); # Convert quiz string to 9*9 recursive list
    board_array = np.array(board_list); # Convert list to array
    # Find out the location of nonzero elements in board_array
    row = []; 
    column = [];
    for j in range(9):
      for k in range(9):
        if board_array[j][k] != 0:
          row.append(j)
          column.append(k)
    row = np.array(row);
    column = np.array(column);
    # List these nonzero elements
    nonzero_values = np.array([board_array[row[d],column[d]] for d in range(len(row))])
    
    location_in_string = 9 * row + column;
    nonzero_and_location = np.block([[nonzero_values],[location_in_string]])
    
    # Use lil_matrix to set an empty len(location_in_string)*729 matrix
    given_constraints = scs.lil_matrix((len(location_in_string), 729))
    # put 1 in the right positions
    for i in range(len(location_in_string)):
        given_constraints[i,location_in_string[i]*9 + nonzero_values[i] - 1] = 1;
    # change back to csr_matrix.
    given_constraints = given_constraints.tocsr() 
    
    return given_constraints

len(quizzes[0])

from cvxopt import solvers, matrix
import time
import random
solvers.options['show_progress'] = False

# Import the data
quizzes = data['quizzes'];
solutions = data['solutions']

corr_cnt = 0
start = time.time()
index = list(range(len(data)))
random_index = random.choices(index,k=1000)
for i in range(len(data)):
    # Set the problem
    quiz = quizzes[i];
    solution = solutions[i];
    # combine all constraints
    A_fixed = fixed_constraints();
    A_given = given_constraint(quiz);

    A_vstack = scs.vstack((A_fixed,A_given));
    A_vstack = A_vstack.toarray();
    one = np.ones(A_vstack.shape[0]);
    # Give A Full Rank, convert the problem to a full-rank problem
    u, s, vh = np.linalg.svd(A_vstack, full_matrices=False)
    nonzero_in_s = np.sum(s>1e-5)
    S_ = np.block([np.diag(s[:nonzero_in_s]), np.zeros((nonzero_in_s, A_vstack.shape[0]-nonzero_in_s))])
    A_svd = S_@vh
    one = u.T@one;
    one = one[:nonzero_in_s];
    # Set the linear optimization problem
    c = matrix(np.ones(1458))
    G = matrix(np.block([[-np.eye(729),np.zeros((729,729))],[np.zeros((729,729)),-np.eye(729)]]))
    h = matrix(np.block([0*np.ones(729),np.zeros(729)]))
    A = matrix(np.block([A_svd, -A_svd]))
    b = matrix(one);
    # Solve it
    sol = solvers.lp(c,G,h,A,b);
    X = np.array(sol['x']).T[0];
    x = X[:729] - X[729:];
    
    # map to board
    answer_string = ''
    for j in range(81):
      for k in range(1,10):
        if round(x[9*j+k-1]) == 1:
            string_number = f'{k}'
            answer_string = answer_string + string_number;

    if answer_string == solution:
        #print("CORRECT")
        corr_cnt += 1
    
    if (i+1) % 50 == 0:
        end = time.time()
        print("Aver Time: {t:6.2f} secs. Success rate: {corr} / {all} ".format(t=(end-start)/(i+1), corr=corr_cnt, all=1000 ))
end = time.time()
print("Aver Time: {t:6.2f} secs. Success rate: {corr} / {all} ".format(t=(end-start)/(i+1), corr=corr_cnt, all=i+1) )

def convert_to_recursive_list(board):
    '''
    Convert the board into a recursive list; each list is one row of the board.
    :board_idx: the index of quizzes
    '''
    lst = list(board)
    temp_list = []
    full_list = []
    for index, num in enumerate(lst):
            temp_list.append(int(num))
            index += 1
            if index % 9 == 0:
                full_list.append(temp_list)
                temp_list = []
    return full_list

def draw_board(board_idx: int):
    '''
    Visualize the suduku board
    '''
    board = quizzes[board_idx]
    for index, num in enumerate(board):
        print(num, end=' | ')
        index += 1
        if index % 9 == 0:
            print('\n===================================')

def convert_to_list_by_submatrix(board_idx):
  '''
  Convert the board into a recursive list; Each list containing a sub-3x3 matrix of the entire board.
  '''
  board = quizzes[board_idx]
  index = [0, 3, 6, 27, 30, 33, 54, 57, 60]
  lst = list(board)
  lst = [int(num) for num in lst]
  full_lst = []
  for idx in index:
    temp_lst = lst[idx:idx+3] + lst[idx+9:idx+12] + lst[idx+18:idx+21]
    full_lst.append(temp_lst)
    temp_lst = []
  return full_lst

def generate_dictionary()-> dict:
  '''
  A helper function. 
  '''
  dic = {}
  for i in range(1, 10):
      dic[i] = False
  return dic

#2. 填入确定值(by row)
def check_by_row(board_list):
    '''
    Check which value from 1-9 is missing by row and plug in the missing value if the value can be determined.
    '''
    dic = generate_dictionary()
    for i in range(9):
        for j in range(9):
            num = board_list[i][j]
            if num != 0:
                dic[num] = True
        bool_values = list(dic.values())
        count_value = bool_values.count(True)
        if count_value == 8:
            board_list[i][board_list[i].index(0)] = list(range(1,10))[bool_values.index(False)]
        dic = generate_dictionary()
    return board_list

def check_by_column(board_list:list):
  
    '''
    Check which number is missing from 1-9 by column and plug in the missing value if the value can be determined.
    '''
    dic = generate_dictionary()
    for i in range(9):
        for j in range(9):
            num = board_list[j][i]
            if num != 0:
                dic[num] = True
        bool_values = list(dic.values())
        count_value = bool_values.count(True)
        if count_value == 9:
            board_list[i][board_list[i].index(0)] = list(range(1,10))[bool_values.index(False)]
        dic = generate_dictionary()
    return board_list

def check_by_submatrix(board_list:list):
  '''
  Check which number is missing from 1-9 by sub-3x3 matrix and plug in the missing value if the value can be determined.
  '''
  dic = generate_dictionary()
  for i in range(9):
      for j in range(9):
          num = board_list[i][j]
          if num != 0:
              dic[num] = True
      bool_values = list(dic.values())
      count_value = bool_values.count(True)
      if count_value == 8:
          board_list[i][board_list[i].index(0)] = list(range(1,10))[bool_values.index(False)]
      dic = generate_dictionary()
  return board_list